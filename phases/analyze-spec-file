#!/usr/bin/env perl

use strict;
use warnings;

use File::Basename;
use DBI;

my ($specfile, $dbfile, $obs_project, $obs_package) = @ARGV;
my $line_number = 0;
my $processed_setup = 0;
my $in_changelog_section = 0;
my $has_changelog = 0;
my %patches = ();
my @applied_patches = ();
my @referenced_patches = ();
my @unreferenced_patches = ();
my $filename = basename ($specfile);
my $name;
my $version;

sub contains {
	my ($target, @arr) = @_;
	foreach (@arr) {
		return 1 if $_ eq $target;
	}
	return 0;
}

my $dbh = DBI->connect ("dbi:SQLite:dbname=$dbfile", "", "", {
	AutoCommit => 0,
	PrintError => 1,
	RaiseError => 1
}) or die "Cannot connect to SQLite database \"$dbfile\"";

open my $in, "<", $specfile or die "Cannot open spec file: $specfile";

while (<$in>) {
	$line_number++;

	s/^\s+//; s/\s+$//;   # trim whitespace
	s/^#.*//; s/\s+#.*//; # strip comments

	if (/^(\w+):\s*(.+)$/) {
		my $field = $1;
		my $value = $2;

		$value =~ s/%{name}/$name/g if $name;
		$value =~ s/%name/$name/g if $name;
		$value =~ s/%{version}/$version/g if $version;
		$value =~ s/%version/$version/g if $version;

		if ($field eq "Name") {
			$name = $value;
		} elsif ($field eq "Version") {
			$version = $value if $value =~ /^[0-9]/;
		} elsif ($field =~ /^Patch/) {
			$field = lc $field;
			@{$patches{$field}} = ($value, 0);
			push @referenced_patches, $value;
		}
	} elsif (/^%(\w+)\s*/) {
		my $directive = $1;
		if ($directive eq "setup") {
			$processed_setup = 1;
		} elsif ($directive =~ /^patch/ && $processed_setup == 1) {
			if ($patches{$directive}) {
				$patches{$directive}[1] = 1;
				push @applied_patches, $patches{$directive}[0];
			}
		} elsif ($directive eq "changelog") {
			$in_changelog_section = 1;
		} else {
			$in_changelog_section = 0;
		}
	} elsif ($in_changelog_section && $_ ne "") {
		$has_changelog = 1;
	}
}

close $in;

# Locate any patch files in the tree that are not mentioned in the spec
my $dirname = dirname ($specfile);
opendir my $dh, $dirname or die "Cannot opendir $dirname";
@unreferenced_patches = grep { 
	/.+\.patch|diff?$/ && -f "$dirname/$_" && 
		! contains $_, @referenced_patches
} readdir $dh;
closedir $dh;

# Remove any existing references to this spec file
my $q = $dbh->prepare ("SELECT spec_id FROM spec_files WHERE name = ? LIMIT 1");
$q->execute ($name);
if ((my ($spec_id) = $q->fetchrow_array) > 0) {
	$dbh->do ("DELETE FROM spec_files WHERE spec_id = ?", undef, $spec_id);
	$dbh->do ("DELETE FROM patches WHERE spec_id = ?", undef, $spec_id);
}
$q->finish ();

# Insert this spec file
$dbh->do ("INSERT INTO spec_files " .
	"(obs_project, obs_package, filename, name, version, has_changelog) " .
	"VALUES (?, ?, ?, ?, ?, ?)",
	undef, $obs_project, $obs_package, $filename, 
	$name, $version, $has_changelog);
my $spec_id = $dbh->func ('last_insert_rowid');

sub insert_patch {
	my ($dbh, $spec_id, $patch_name, $application_order, $is_unref) = @_;
	$dbh->do ("INSERT INTO patches " .
		"(spec_id, name, application_order, unreferenced)" .
		"VALUES (?, ?, ?, ?)", undef,
		$spec_id, $patch_name, $application_order, $is_unref);
}

# First insert applied patches, logging their application order
my $application_order = 0;
insert_patch $dbh, $spec_id, $_, $application_order++, 0 foreach @applied_patches;

# Then log patches that are in the tree but not mentioned in the spec file
insert_patch $dbh, $spec_id, $_, -1, 1 foreach @unreferenced_patches;

# Finally log patches that are mentioned in the spec, but are not applied
foreach (values %patches) {
	insert_patch $dbh, $spec_id, @{$_}[0], -1, 0 if @{$_}[1] == 0;
}

$dbh->commit ();
$dbh->disconnect ();
